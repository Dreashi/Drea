红黑树：Red-Black Tree,特殊的二叉查找树。
特性：
1.每个节点为红色或黑色。
2.根节点为黑色。
3.为空的叶子结点为黑色。
4.红色结点的子节点必须为黑色。
5.从一个结点到该节点的子孙节点（子孙叶子结点？）的所有路径上包含相同数目的黑结点。--确保没有一条路径会比其他路径长出两倍。

红黑树应用：
用来存储有序的数据，时间复杂度为O(lg n)。
JAVA中的TreeSet，TreeMap，C++ STL中的set，map，Linux虚拟内存管理

左旋和右旋:
原因:添加或删除红黑树中的结点后，红黑树可能不满足红黑树的5条性质，通过旋转让其保持红黑树的性质。


左旋过程：
假设x的右孩子为y;
1.把y的左孩子赋给y的右孩子；
2.把x的父节点变成y的父节点；
3.把x变成y的左孩子；

右旋过程：
假设y的左孩为x
1.把x的右孩子赋给y的左孩子；
2.把y的父节点变成x的父节点；
3.把y变成x的右孩子。

红黑树插入操作：
将红黑树当做一颗二叉查找树进行插入，将插入的结点着色为红色（涂红色只可能违背性质4），通过旋转和重新着色进行修正。
case1：插入节点为根节点，直接涂黑色；
case2：插入节点的父节点为黑色，还是红黑树，不用处理；
cass3:插入节点的父节点为红色：
	case1：父节点和叔叔结点为红色：把父亲节点和叔叔结点涂黑色，祖父节点涂红色，以祖父节点为 当前节点接续处理。
	case2：父节点为红色，叔叔结点为黑色，当前结点为右孩子：以父节点为当前节点左旋。
	case3：父节点为红色，叔叔结点为黑色，当前节点为左孩子：父节点涂黑，祖父节点涂红，以祖父节点为支点右旋。

处理思想：把红色结点移为根节点，然后涂黑。

红黑树删除操作：
1.将红黑树当做一颗二叉查找树，将给节点从二叉查找树中删除，在通过旋转和着色修正。
将结点从二叉查找树中删除：
1.被删除节点为叶子结点，直接删除；
2.被删除节点只有一个儿子，删除结点并用其子树顶替其位置；
3.被删除结点有两个儿子。将其中序遍历的后继结点的内容复制到被删结点的位置，删除其后继结点。

删除y后，x占据了y的位置，为了不违反特性5，假设给x再额外增加一个黑色。
1.x是“红+黑”，直接把x设为黑色；
2.x是“黑+黑”且是根，什么都不做；
3.x是“黑+黑”且不是根。
（1）、x的兄弟结点是红色（x的父节点和其兄弟结点的子节点都是黑色）：
1> 将x的兄弟结点设为黑；
2> 将x的父节点设为黑；
3> 对x的父节点左旋；
4> 重新设置x的兄弟结点；

（2）、x的兄弟结点和它的两个子节点都为黑色：
1> 将x的兄弟结点设为红色；
2> 设置x的父节点为x结点；

(3)、x的兄弟结点是黑，x的兄弟结点的孩子左红右黑：
1> 将x兄弟结点的左孩子涂黑；
2> 将x兄弟结点涂红；
3> 对x兄弟结点右旋；
4> 重新设置x的兄弟结点；

（4）、x的兄弟结点为黑，x兄弟结点的右孩子为红，左孩子任意：
1> 将x父节点的颜色赋给x的兄弟结点 ；
2> 将x父节点涂黑；
3> 将x兄弟结点的右孩子涂黑；
4> 对x父节点左旋；
5> 设置x为根节点；













